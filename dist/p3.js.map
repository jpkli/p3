{"version":3,"sources":["webpack:///webpack/bootstrap b917c0bf163c92743289","webpack:///./src/arrays.js","webpack:///./src/aggregate.js","webpack:///./src/match.js","webpack:///./src/derive.js","webpack:///./index.js","webpack:///../node_modules/webpack/buildin/global.js","webpack:///./src/allocate.js","webpack:///./src/pipeline.js","webpack:///./src/query.js","webpack:///./src/join.js","webpack:///./src/stats.js","webpack:///./src/embed.js","webpack:///./src/toarray.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,sBAAsB;AAC/D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA,oBAAoB,QAAQ;AAC5B;;AAEA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;;AAEA,mBAAmB,cAAc;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,iDAAiD;AACjD;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,YAAY;AAC9B;AACA;AACA;;AAEA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,0BAA0B;;AAEhE;AACA;;AAEA;AACA;AACA;;;;AAIA;;;;;;;AC9LA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,8CAA8C,kBAAkB;AAChE;AACA;AACA;;AAEA,sBAAsB,OAAO;AAC7B;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qEAAqE,gBAAgB,EAAE;AACvF,iFAAiF,gBAAgB,EAAE;AACnG,aAAa;AACb;AACA,uFAAuF,eAAe,EAAE;AACxG,iBAAiB;AACjB,sEAAsE,gBAAgB,EAAE;AACxF,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA,2DAA2D,gBAAgB,EAAE;AAC7E;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,+DAA+D,mBAAmB;AAClF;AACA,yBAAyB;AACzB,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;;;;;;AC9IA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;;;;;;ACxDA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,yCAAyC;AACzC,aAAa;AACb,yHAAyH;AACzH;AACA,SAAS;;AAET;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;;;;;;;AC5BA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;;;;;;;;ACvBA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;ACpBA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe;AACf;;AAEA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,uBAAuB,UAAU;AACjC;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;AClJA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;;;;;;AC3HA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,mCAAmC,cAAc;AACjD;;AAEA;AACA,qCAAqC,cAAc;AACnD;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;;;AAIJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,+DAA+D,cAAc;AAC7E;AACA;AACA;;AAEA;AACA;AACA,2DAA2D,oCAAoC;AAC/F;AACA;AACA,qCAAqC,mBAAmB,EAAE;AAC1D;AACA;AACA;AACA;AACA;AACA;;;AAGA,kBAAkB,YAAY;AAC9B,mBAAmB;AACnB;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,QAAQ;;AAER;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;;AAEA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,aAAa;AAC/B,yBAAyB;AACzB;;AAEA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B,KAAK;;AAEL,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yCAAyC,aAAa,EAAE;AACxD;AACA,KAAK;;AAEL;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,8DAA8D,UAAU,EAAE;;AAE1E;AACA,8CAA8C,gBAAgB;AAC9D,KAAK;;AAEL;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;;;;;;ACjOA;AACA;AACA;AACA;;AAEA,wCAAwC,mCAAmC;;AAE3E;AACA,sBAAsB,SAAS;AAC/B,6C;AACA;AACA,KAAK;;AAEL;AACA;;;;;;;ACdA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,qCAAqC,YAAY,EAAE;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA,qCAAqC,YAAY,EAAE;AACnD;AACA,KAAK;;AAEL;AACA;;AAEA;;;;;;;ACrCA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,cAAc,eAAe;;AAEvE,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;AC1BA;AACA,2BAA2B;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,KAAK;AACL;AACA,wCAAwC,aAAa,EAAE;AACvD,SAAS;AACT;AACA","file":"p3.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b917c0bf163c92743289","var array = {};\nfunction _reduce(array, opt) {\n    var i,\n        len = array.length,\n        fn,\n        result;\n\n    if(!len) return 0;\n\n    switch (opt) {\n        case \"max\":\n            result = array.reduce(function(a, b) {\n                return (a > b) ? a : b;\n            });\n            break;\n        case \"min\":\n            result = array.reduce(function(a, b) {\n                return (a < b) ? a : b;\n            });\n            break;\n        case \"and\":\n        case \"&\":\n            result = array.reduce(function(a, b) {\n                return a & b;\n            });\n            break;\n        case \"or\":\n        case \"|\":\n            result = array.reduce(function(a, b) {\n                return a | b;\n            });\n            break;\n        case \"mult\":\n        case \"*\":\n            result = array.reduce(function(a, b) {\n                return a * b;\n            });\n            break;\n        default: // \"sum\" or \"+\"\n            result = array.reduce(function(a, b) {\n                return a + b;\n            });\n            break;\n    }\n\n    return result;\n}\n\narray.reduce = function(opt) {\n    return function(array) {\n        var a = (array instanceof Array) ? array : Array.apply(null, arguments);\n        return _reduce(a, opt);\n    };\n};\n\narray.avg = function(array) {\n    return _reduce(array, \"+\") / array.length;\n    // return array.reduce(function(a,b){ return 0.5 * (a + b)});\n};\n\narray.normalize = function(array) {\n    var max = _reduce(array, \"max\"),\n        min = _reduce(array, \"min\"),\n        range = max - min;\n\n    return array.map(function(a){\n        return (a - min) / range;\n    });\n}\n\narray.seq = function(start, end, intv) {\n    var interval = intv || 1,\n        array = [];\n\n    for(var i=start; i<=end; i+=interval)\n        array.push(i);\n\n    return array;\n};\n\n[\"max\", \"min\", \"mult\", \"and\", \"or\"].forEach(function(f) {\n    array[f] = array.reduce(f);\n});\n\narray.sum = array.reduce(\"+\");\n\narray.scan = array.pfsum = function(a){\n    var pfsum = [],\n        accum = 0;\n\n    for (var i = 0; i < a.length; i++) {\n        accum += a[i];\n        pfsum.push(accum);\n    }\n\n    return pfsum;\n};\n\narray.iscan = function(a) {\n    return array.scan([0].concat(a));\n};\n\narray.diff = function(a, b) {\n    var difference = [];\n    a.forEach(function(d){\n        if (b.indexOf(d)===-1) {\n            difference.push(d);\n        }\n    });\n    return difference;\n};\n\narray.intersect = function(a, b) {\n    var t;\n    if (b.length > a.length) t = b, b = a, a = t; // indexOf to loop over shorter\n    return a.filter(function (e) {\n            if (b.indexOf(e) !== -1) return true;\n    });\n};\n\narray.unique = function(a) {\n    return a.reduce(function(b, c) {\n        if (b.indexOf(c) < 0) b.push(c);\n        return b;\n    }, []);\n};\n\narray.lcm = function(A) {\n    var n = A.length, a = Math.abs(A[0]);\n    for (var i = 1; i < n; i++) {\n        var b = Math.abs(A[i]), c = a;\n        while (a && b){ (a > b) ? a %= b : b %= a; }\n        a = Math.abs(c*A[i])/(a+b);\n    }\n    return a;\n};\n\narray.stats = function(array){\n    return {\n        max: _reduce(array, \"max\"),\n        min: _reduce(array, \"min\"),\n        avg: array.avg(array)\n    };\n};\n\narray.histogram = function(array, numBin, _max, _min) {\n    var l = array.length,\n        min = (typeof(_min) == 'number') ? _min : _reduce(array, \"min\"),\n        max = (typeof(_max) == 'number') ? _max : _reduce(array, \"max\"),\n        range = max - min,\n        interval = range / numBin,\n        bins = [],\n        // ids = [],\n        hg = new Array(numBin+1).fill(0);\n\n    for(var b = 0; b < numBin; b++) {\n        bins.push([min + range * (b/(numBin)), min + range*(b+1)/(numBin)]);\n        // ids[b] = [];\n    }\n\n    // ids[numBin] = [];\n\n    for(var i = 0; i < l; i++) {\n        binID = Math.floor( (array[i] - min) / range * (numBin));\n        hg[binID]++;\n        // ids[binID].push(i);\n    };\n\n    hg[numBin-1] += hg[numBin];\n    // ids[numBin-1] = ids[numBin-1].concat(ids.pop());\n    return {\n        bins: bins,\n        counts: hg.slice(0,numBin),\n        // ids: ids\n    };\n}\n\narray.var = function(rowArray) {\n    var m = _reduce(rowArray, \"+\") / rowArray.length,\n        va = rowArray.map(function(a){ return Math.pow(a-m, 2) });\n\n    return _reduce(va, \"+\") / (rowArray.length - 1);\n}\n\narray.std = function(rowArray) {\n    return Math.sqrt(array.var(rowArray));\n}\n\n\n\nmodule.exports = array;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/arrays.js\n// module id = 0\n// module chunks = 0","var ArrayOpts = require(\"./arrays.js\");\n\nmodule.exports = function(data, spec, headers){\n    var i,\n        l = data.length,\n        attributes = headers || Object.keys(data[0]),\n        bin,\n        bins = [],\n        binCollection = {},\n        result = [],\n        ks;\n\n    if(!spec.hasOwnProperty('$group') && !spec.hasOwnProperty('$bin')) return result;\n\n    if(typeof spec.$bin == 'object') {\n        var binAttr = Object.keys(spec.$bin)[0],\n            binCount = spec.$bin[binAttr];\n\n        if(attributes.indexOf(binAttr) !== -1) {\n            var column = data.map(function(d){return d[binAttr]}),\n                min = ArrayOpts.min(column),\n                max = ArrayOpts.max(column),\n                binInterval = (max - min) / binCount;\n\n            for(i = 0; i < l; i++){\n                data[i]['bin@' + binAttr] = Math.min(Math.floor(data[i][binAttr]/binInterval), binCount-1);\n            }\n\n            spec.$group = 'bin@' + binAttr;\n            attributes.push('bin@' + binAttr);\n        }\n    }\n\n    for(i = 0; i < l; i++){\n        if(Array.isArray(spec.$group)) {\n            ks = [];\n            spec.$group.forEach(function(si){\n                ks.push(data[i][si]);\n            });\n            bin = JSON.stringify(ks);\n        } else {\n            bin = data[i][spec.$group];\n        }\n        if( bins.indexOf(bin) < 0 ){\n            bins.push(bin);\n            binCollection[bin] = [data[i]];\n        } else {\n            binCollection[bin].push(data[i]);\n        }\n    }\n\n    var bl = bins.length;\n\n    for(i = 0; i < bl; i++){\n        var res = {};\n        if(Array.isArray(spec.$group)) {\n            ks = JSON.parse(bins[i]);\n            spec.$group.forEach(function(s, j){\n                res[s] = ks[j];\n            })\n\n        } else {\n            res[spec.$group] = bins[i];\n        }\n\n        if(spec.$data) {\n            res.data = binCollection[bins[i]];\n        }\n\n        if(spec.$group) {\n            var gkeys = Array.isArray(spec.$group) ? spec.$group : [spec.$group];\n\n            gkeys.forEach(function(gk){\n                if(attributes.indexOf(gk) === -1) {\n                    throw Error('Invalid attribute name: ', gk);\n                }\n            })\n        }\n\n        var out = spec.$collect || spec.$reduce || [];\n        var keys = Object.keys(out);\n        if(keys.length === 0) return result;\n        keys.forEach(function(key){\n            var attr = key,\n                opt = out[key];\n\n            if(opt === \"$count\" || opt === \"$data\") {\n                attr = key;\n            }\n            if(typeof out[key] === 'object'){\n                opt = Object.keys(out[key])[0];\n                attr = out[key][opt];\n\n                if(attributes.indexOf(attr) === -1 && attr !== \"*\" && !Array.isArray(attr)) {\n                    var warnMsg = \"No matching attribute or operation defined for the new attribute \" + key + \":\" + spec[key];\n                    console.warn(warnMsg);\n                    return;\n                }\n            }\n\n            if(typeof opt === \"function\") {\n                // res[key] = binCollection[bins[i]].map(function(a){ return a[attr]; }).reduce(opt);\n                res[key] = opt.call(null, binCollection[bins[i]].map(function(a){ return a[attr]; }));\n            } else if(typeof opt === \"string\") {\n                if(opt === \"$unique\") {\n                    res[key] = ArrayOpts.unique(binCollection[bins[i]].map(function(a){ return a[key]; }));\n                } else if (opt === \"$list\") {\n                    res[key] = binCollection[bins[i]].map(function(a){ return a[attr]; });\n                } else if (opt === \"$first\") {\n                    res[key] = binCollection[bins[i]][0][attr];\n                } else if (opt === \"$merge\") {\n                    var mergedResult = [];\n                    binCollection[bins[i]].map(function(a){ return a[attr]; }).forEach(function(m){\n                        mergedResult = mergedResult.concat(m);\n                    })\n                    res[key] = mergedResult;\n                } else if (opt === \"$count\") {\n                    res[key] = binCollection[bins[i]].length;\n                } else if (opt === \"$data\") {\n                    var collect = (spec.$collect) ? '$collect' : '$reduce';\n                    res[key] = (spec[collect][key][opt] == '*')\n                        ? binCollection[bins[i]]\n                        : binCollection[bins[i]].map(function(data){\n                            var row = {};\n                            spec[key][opt].forEach(function(k){ row[k] = data[k] });\n                            return row;\n                        });\n                } else {\n                    var fname = opt.slice(1);\n\n                    if(fname in ArrayOpts) {\n                        res[key] = ArrayOpts[fname].call(null, binCollection[bins[i]].map(function(a){\n                            return a[attr];\n                        }));\n                    }\n                }\n            }\n        });\n        result.push(res);\n    }\n\n    return result;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/aggregate.js\n// module id = 1\n// module chunks = 0","module.exports = function match(data, spec) {\n    var indexes = data[0];\n\n    if(!Array.isArray(indexes)) indexes = [];\n\n    return data.filter(function(a){\n        if(_match(a, spec, indexes)) return a;\n    });\n};\n\nfunction _match(obj, spec, indexes){\n    var match,\n        opt,\n        index,\n        sat = true,\n        keys = Object.keys(spec);\n\n    keys.forEach(function(key){\n        if(key === \"$not\") {\n            match = !_match(obj, spec[key], indexes);\n        } else if(key == \"$or\" || key == \"$and\" ) {\n            match = (key == \"$and\");\n            spec[key].forEach(function(s){\n                match = (key == \"$and\") ? match & _match(obj, s, indexes) : match | _match(obj, s, indexes);\n            });\n        } else {\n            index = (indexes.length > 0) ? indexes.indexOf(key) : key;\n\n            if(typeof spec[key] === 'object'){\n                opt = Object.keys(spec[key])[0];\n\n                if(opt[0] == \"$\" && spec[key][opt] instanceof Array){\n                    if(opt == \"$in\" || opt == \"$nin\"){\n                        match = ((opt == \"$nin\") ^ (spec[key][opt].indexOf(obj[index]) > -1));\n                    } else if(opt == \"$inRange\"){\n                        match =(obj[key] >= spec[key][opt][0] & obj[index] <= spec[key][opt][1]);\n                    } else if(opt == \"$ninRange\"){\n                        match =(obj[key] < spec[key][opt][0] | obj[index] > spec[key][opt][1]);\n                    } else if(opt == \"$inDate\"){\n                        match = (spec[key][opt].map(Number).indexOf(+(obj[index])) > -1);\n                    }\n                } else if(spec[key] instanceof Array) {\n                    match =(obj[key] >= spec[key][0] & obj[index] <= spec[key][1]);\n                }\n            } else {\n                if(spec[key][0] === \"$\") {\n                    match = (obj[spec[key].slice(1)] === obj[index]);\n                } else {\n                    match = (spec[key] == obj[index]);\n                }\n            }\n        }\n        sat = sat & match;\n    });\n\n    return sat;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/match.js\n// module id = 2\n// module chunks = 0","var $ = require('./arrays.js');\n\nmodule.exports = function(data, spec){\n    if(!Array.isArray(data))\n        throw new Error(\"Inproper input data format.\");\n\n    if(typeof(spec) === \"function\") {\n        data.forEach(spec);\n    } else {\n        var result = [],\n            tranfs = {};\n\n        Object.keys(spec).forEach(function(s){\n            if(typeof(spec[s]) == \"function\") {\n                tranfs[s] = function(d) { d[s] = spec[s](d) };\n            } else {\n                tranfs[s] = Function(\"attr\", \"attr.\" + s + \"=\" + spec[s].replace(/@/g, 'attr.').replace(/\\$/g, '$.') + \";\");\n            }\n        });\n\n        data.forEach(function(d){\n            Object.keys(spec).forEach(function(s){\n                tranfs[s](d);\n            });\n        });\n    }\n\n    return data;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/derive.js\n// module id = 3\n// module chunks = 0","var root = typeof self == 'object' && self.self === self && self ||\n           typeof global == 'object' && global.global === global && global ||\n           this;\n\nvar p3 = {\n    allocate    : require('./src/allocate'),\n    arrays      : require('./src/arrays'),\n    aggregate   : require('./src/aggregate'),\n    pipeline    : require('./src/pipeline'),\n    derive      : require('./src/derive'),\n    match       : require('./src/match'),\n    join        : require('./src/join'),\n    stats       : require('./src/stats'),\n    embed       : require('./src/embed'),\n    toArray     : require('./src/toarray')\n};\n\nif(typeof root.p3 == 'object') {\n    root.p3 = Object.assign(root.p3, p3);\n} else {\n    root.p3 = p3;\n}\n\nmodule.exports = p3;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./index.js\n// module id = 4\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../node_modules/webpack/buildin/global.js\n// module id = 5\n// module chunks = 0","/**\n * alloc(options) - allocating memory for storing data values in different schemaures.\n * @exports allocate\n * @param {Object} options - Options for allocating memory.\n * @param {Array} options.array - Array containing the data values.\n * @param {Array} options.fields - Fields in the data.\n * @param {number} [options.skip=0] - Number of rows to be skiped in data.\n * @param {object[]} [options.data] - default data\n *\n */\nmodule.exports = function allocate(options) {\n    'use strict';\n    var array = options.array || [],\n        header = options.fields || options.header || array[0],\n        types = options.types || [],\n        schema = options.schema || undefined,\n        skip = options.skip || 0,\n        data = options.data || [];\n\n    var ds = {},\n        parsers = [];\n\n    if (types.length && typeof(types) == 'string') {\n        var ta = [];\n        for (var i = 0; i < header.length; i++) {\n            ta.push(types);\n        }\n        types = ta;\n    }\n\n    if (typeof schema == 'object') {\n        header = Object.keys(schema);\n        types = Object.keys(schema).map(function(h) {\n            return schema[h];\n        });\n    }\n\n    if (typeof skip == 'number') {\n        for (var j = 0; j < skip; j++)\n            array.shift();\n    }\n\n    types.forEach(function(t) {\n        parsers.push(getParser(t));\n    })\n\n    function getParser(type) {\n        if (type == 'int' || type.match('veci*')) {\n            return function(value) {\n                var res = parseInt(value);\n                return (isNaN(res)) ? 0 : res;\n            };\n        } else if (type == 'float' || type.match('vecf*')) {\n            return function(value) {\n                var res = parseFloat(value);\n                return (isNaN(res)) ? 0 : res;\n            };\n        } else if (['date', 'time', 'datetime'].indexOf(type) != -1) {\n            return function(value) {\n                return new Date(value);\n            };\n        } else if (['money', 'price', 'cost'].indexOf(type) != -1) {\n            return function(value) {\n                return parseFloat(value.substring(1));\n            };\n        } else {\n            return function(value) {\n                return value;\n            };\n        }\n    }\n\n    ds.insertRows = function(rows) {\n        array = array.concat(rows);\n    }\n    \n    /**\n    * @method objectArray\n    * @return {Object[]} - Return data as array of objects\n    */\n    ds.objectArray = function() {\n        if (typeof(header) !== 'undefined' && header.length) {\n            var l = header.length;\n            array.forEach(function(a) {\n                var o = {},\n                    offset = 0;\n                for (var i = 0; i < l; i++) {\n                    var k = header[i];\n                    if (k.length) {\n                        if (types[i].match(/^(veci|vecf)\\d+$/)) {\n                            var vl = parseInt(types[i].slice(4)),\n                                vector = [];\n                            a.slice(offset, offset + vl).forEach(function(vi) {\n                                vector.push(parsers[i](vi));\n                            });\n                            o[k] = vector;\n                            offset += vl;\n                        } else {\n                            o[k] = parsers[i](a[offset]);\n                            offset++;\n                        }\n                    }\n                }\n                data.push(o);\n            });\n        }\n        return data;\n    }\n\n    /**\n    * @method rowArray\n    * @return {Array[]} - data as row arrays\n    */\n    ds.rowArray = function() {\n        array.forEach(function(a) {\n            var row = [];\n            header.forEach(function(k, i) {\n                if (k.length) {\n                    row.push(parsers[i](a[i]));\n                }\n            });\n            data.push(row);\n        });\n        data.fields = header;\n        data.schema = 'rowArray';\n        return data;\n    }\n\n    /**\n    * @method collumArray\n    * @return {Array[]} - data as column arrays\n    */\n    ds.columnArray = function() {\n        header.forEach(function(k, i) {\n            var column = array.map(function(a) {\n                return parsers[i](a[i]);\n            });\n            data.push(column);\n        });\n        data.fields = header;\n        data.schema = 'columnArray';\n        return data;\n    }\n    //TODO: make columnArray extensible like rowArray and objectArray\n\n    return ds;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/allocate.js\n// module id = 6\n// module chunks = 0","const derive = require('./derive');\nconst queries = require('./query');\nconst aggregate = require('./aggregate');\nconst match = require('./match');\n\nmodule.exports = function pipeline (data){\n    var queue = [],\n        cache = {},\n        opt = {},\n        workers = [],\n        completed = 0,\n        result = [],\n        callback = function() {};\n\n    if(Array.isArray(data)) {\n        result = data;\n    }\n\n    opt.derive = derive;\n    opt.match = match;\n    opt.aggregate = aggregate;\n\n    Object.keys(queries).forEach(function(f) {\n        opt[f] = queries[f];\n    });\n\n    opt.cache = function(data, tag){\n        cache[tag] = pipeline.result();\n    };\n\n    opt.map = function(f){\n        result = data.map(f);\n        return pipeline;\n    };\n\n    var merge = {\n        aggregate: function (lastJob) {\n            var mergeSpec = {};\n            for(var key in lastJob.aggregate) {\n                var optSpec = lastJob.aggregate[key];\n                if(typeof optSpec == 'object')\n                    mergeSpec[key] = Object.keys(optSpec)[0];\n                else\n                    mergeSpec[key] = optSpec;\n            }\n            return opt.aggregate(finalResult, mergeSpec);\n        }\n    }\n\n    var finalResult = [];\n\n    function mergeResult(workerResult) {\n        var rl = finalResult.length,\n            wl = workerResult.length;\n        for(var i = 0; i < wl; i++) {\n            finalResult[rl+i] = workerResult[i];\n        }\n        completed += 1;\n\n        if(completed == workers.length) {\n            var lastJob = queue[queue.length-1],\n                lastJobOpt = Object.keys(lastJob)[0];\n            if( lastJobOpt == 'aggregate') {\n                finalResult = merge.aggregate(lastJob);\n            }\n            callback(finalResult);\n        }\n    }\n\n    var pipeline = {};\n\n    // pipeline.opt = opt;\n    Object.keys(opt).forEach(function(o){\n        pipeline[o] = function(spec) {\n            var task = {};\n            task[o] = spec;\n            queue.push(task);\n            return pipeline;\n        };\n    })\n\n    pipeline.then = function(_callback) {\n        callback = _callback;\n        queue.forEach(function(q){\n            var f = Object.keys(q)[0];\n            result = opt[f](result, q[f]);\n        });\n        return result;\n    }\n\n    pipeline.execute = function(data) {\n        if(Array.isArray(data)) result = data;\n        queue.forEach(function(q){\n            var f = Object.keys(q)[0];\n            result = opt[f](result, q[f]);\n        });\n        return result;\n    }\n\n    pipeline.oncomplete = pipeline.then;\n\n    pipeline.result = function() {\n        return result;\n    };\n\n    pipeline.data = function(data) {\n        result = data;\n        return pipeline\n    }\n\n    pipeline.queue = function() {\n        return queue;\n    }\n\n    pipeline.runSpec = function(specs) {\n        specs.forEach(function(spec){\n            let opt = Object.keys(spec)[0];\n            pipeline[opt.replace('$', '')](spec[opt])\n        })\n        return pipeline.execute();\n    }\n\n    return pipeline;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/pipeline.js\n// module id = 7\n// module chunks = 0","const arrayOpts = require(\"./arrays.js\");\nconst aggregate = require(\"./aggregate.js\");\nconst match = require(\"./match.js\");\n\nvar query = {};\nquery.match = match;\nquery.group = aggregate;\n\nquery.indexBy = function(data, id){\n    var indexed = {};\n    data.forEach(function(d){\n        if(!indexed.hasOwnProperty(d[id])){\n            indexed[d[id]] = [ d ];\n        } else {\n            indexed[d[id]].push(d);\n        }\n        delete d[id];\n    });\n    return indexed;\n};\n\n// query.list = function(data, id) {\n//     return data.map(function(d){return d[id];});\n// }\n\nquery.range = function(data, id) {\n    var array = data.map(function(d){return d[id];});\n    return [ arrayOpts.min(array), arrayOpts.max(array) ];\n};\n\nquery.map = function(data, m) {\n    var mf = function(d){return d};\n    if(typeof m === \"string\")\n        mf = function(d){return d[m]};\n    else if(typeof m === \"function\")\n        mf = m;\n\n    return data.map(mf);\n};\n\n// Object.keys(arrayOpts).forEach(function(opt) {\n//     query[opt] = function(data, id) {\n//         var arr = query.map(data, id);\n//         return arrayOpts[opt](arr);\n//     }\n// });\n\n\n\nquery.sortBy = function(data, spec) {\n    function sortArray(a, b, p) {\n        return a[p] > b[p] ? 1 : a[p] < b[p] ? -1 : 0;\n    }\n    return data.sort(function(a, b){\n        var r = 0,\n            i = 0,\n            attributes = Object.keys(spec),\n            al = attributes.length;\n\n        while( r === 0 && i < al ) {\n            r = sortArray(a, b, attributes[i]) * spec[attributes[i]];\n            i++;\n        }\n        return r;\n    })\n};\n\nquery.orderBy = function(c, s, o) {\n    var spec = {};\n    s.forEach(function(ss){\n        spec[ss] = o;\n    });\n    return query.sort(c, spec);\n};\n\nquery.histogram = function(data, spec, max, min) {\n    var result = {};\n    for(var key in spec) {\n        result[key] = arrayOpts.histogram(data.map(function(d){return d[key]}), spec[key], max, min);\n    }\n    return result;\n};\n\nquery.binAggregate = function(data, spec) {\n    var attrKey = Object.keys(spec)[0],\n        attributes = Object.keys(spec).filter(function(k) { return k != \"$data\" && k!=attrKey;}) || [],\n        embedData = spec.$data || false,\n        numBin = spec[attrKey],\n        array = data.map(function(d){ return d[attrKey]; }),\n        l = array.length,\n        min = arrayOpts.min(array),\n        max = arrayOpts.max(array),\n        range = max - min,\n        interval = range / numBin,\n        bins = [];\n\n\n    for(var b = 0; b < numBin; b++) {\n        bins[b] = {binID: b, rangeBegin: min + range * (b/(numBin)), rangeEnd: min + range*(b+1)/(numBin), count: 0};\n        // if(embedData)\n            bins[b].data = [];\n        // attributes.forEach(function(attr){\n        //     bins[b][attr] = 0;\n        // })\n    }\n\n    // bins[numBin] = [];\n\n    for(var i = 0; i < l; i++) {\n        binID = Math.floor( (array[i] - min) / range * (numBin));\n        if(binID == numBin) binID--;\n        data[i].binID = binID;\n        // if(embedData)\n            bins[binID].data.push(data[i]);\n        // bins[binID].count++;\n        // attributes.forEach(function(attr){\n        //     bins[binID][attr] += data[i][attr];\n        // });\n    }\n\n    spec.$by = \"binID\";\n    delete spec[attrKey];\n\n    var result = query.group(data, spec);\n    result = query.indexBy(result, \"binID\");\n\n\n    // result.forEach(function(r){\n    //     r.rangeBegin = bins[r.binID].rangeBegin;\n    //     r.rangeEnd = bins[r.binID].rangeEnd;\n    // })\n\n    bins.forEach(function(bin){\n\n        if(result.hasOwnProperty(bin.binID)) {\n            attributes.forEach(function(attr){\n                bin[attr] = result[bin.binID][0][attr];\n            });\n            if(embedData) bin.data = result[bin.binID][0].data;\n        } else {\n            attributes.forEach(function(attr){\n                bin[attr] = 0;\n            });\n        }\n\n    })\n    // console.log(bins);\n    // return result;\n    return bins;\n}\n\nquery.partition = function(data, numPart) {\n    var len = data.length,\n        p = Math.ceil(len / numPart),\n        pid,\n        partitions = [];\n\n    for(var b = 0; b < numPart; b++) {\n        partitions[b] = {partition: b, data: [], count: 0};\n    }\n\n    for(var i = 0; i < len; i++) {\n        pid = Math.floor(i / p);\n        partitions[pid].data.push(data[i]);\n        partitions[pid].count++;\n    }\n\n    return partitions;\n}\n\nquery.partitionBy = function(data, spec) {\n    var len = data.length,\n        pid,\n        partitions = [],\n        key = Object.keys(spec)[0],\n        parts = spec[key];\n\n    parts.forEach(function(b, bi) {\n        partitions[bi] = {partition: bi, data: [], count: 0, name: b};\n    })\n\n    for(var i = 0; i < len; i++) {\n        pid = parts.indexOf(data[i][key]);\n        if(pid>-1){\n            partitions[pid].data.push(data[i]);\n            partitions[pid].count++;\n        }\n    }\n    return partitions;\n}\n\nquery.normalize = function(data, fields) {\n    var hash = {};\n\n    fields.forEach(function(f){\n        var array = data.map(function(d){ return d[f]; });\n        hash[f] = arrayOpts.normalize(array);\n    });\n\n    data.forEach(function(d, i){\n        fields.forEach(function(f){\n            d[f] = hash[f][i];\n        });\n    });\n\n    return data;\n}\n\nquery.toColumnArray = function(data) {\n    var columnArray = [];\n        attributes = Object.keys(data[0]).filter(function(k) { return k; });\n\n    attributes.forEach(function(attr){\n        columnArray.push(data.map(function(d){return d[attr];}));\n    });\n\n    columnArray.fields = attributes;\n\n    attributes.forEach(function(attr, ai){\n        columnArray[attr] = columnArray[ai];\n    });\n\n    return columnArray;\n}\n\nmodule.exports = query;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/query.js\n// module id = 8\n// module chunks = 0","module.exports = function join(dataLeft, dataRight) {\n    var len = dataLeft.length,\n        keyL = Object.keys(dataLeft[0]),\n        keyR = Object.keys(dataRight[0]);\n        \n    var keys = keyR.filter(function(kr){ return (keyL.indexOf(kr) === -1);});\n\n    keys.forEach(function(k){\n        for(var i = 0; i < len; i++) {\n            dataLeft[i][k] = dataRight[i][k];    \n        }\n    });\n\n    return dataLeft;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/join.js\n// module id = 9\n// module chunks = 0","var array = require(\"./arrays\");\n\nfunction stats(data, fields){\n\n    if(!Array.isArray(data))\n        throw new Error(\"Inproper input data format.\");\n\n    var result = {};\n\n    fields.forEach(function(f) {\n        var a = data.map(function(d){return d[f]; });\n        result[f] = {\n            min: array.min(a),\n            max: array.max(a),\n            avg: array.avg(a),\n            std: array.std(a)\n        };\n    });\n\n    return result;\n};\n\n\nstats.domains = function(data, fields) {\n    if(!Array.isArray(data))\n        throw new Error(\"Inproper input data format.\");\n\n    var result = {};\n\n    fields.forEach(function(f) {\n        var a = data.map(function(d){return d[f]; });\n        result[f] = [ array.min(a), array.max(a) ];\n    });\n\n    return result;\n}\n\nmodule.exports = stats;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/stats.js\n// module id = 10\n// module chunks = 0","module.exports = function embed(spec) {\n    var id = spec.$id || spec.$by,\n        attributes = Object.keys(spec);\n\n    if(!id) throw Error(\"No id specified for embed!\");\n\n    attributes.filter(function(attr){\n        return (attr != \"$by\" && attr != \"$id\")\n    })\n    .forEach(function(attr){\n        var embedKey = spec[attr][0][id],\n            i = 0,\n            n = data.length,\n            l = spec[attr].length;\n\n        var lookup = data.map(function(d){ d[attr] = []; return d[id];});\n\n        for(i = 0; i < l; i++) {\n            var index = lookup.indexOf(spec[attr][i][id]);\n            if(index !== -1) {\n                data[index][attr].push(spec[attr][i]);\n            }\n            // delete spec[attr][i][id];\n        }\n    });\n    return data;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/embed.js\n// module id = 11\n// module chunks = 0","module.exports = function toArray(data, arg){\n    var options = arg || {},\n        fields = options.fields || Object.keys(data[0]) || [],\n        format = options.format || 'row';\n\n    if(format == 'row') {\n        return data.map(function(d){\n            var row = new Array(fields.length);\n            fields.forEach(function(f, i){\n                row[i] = d[f];\n            });\n            return row;\n        });\n    } else {\n        return fields.map(function(f){\n            return data.map(function(d){ return d[f]; })\n        })\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/toarray.js\n// module id = 12\n// module chunks = 0"],"sourceRoot":""}